Source code architecture description
------------------------------------

live-f1 uses libevent (asynchronous callbacks library) for network
communications and ncurses for in-terminal screen drawing.

Common data structures are defined at src/live-f1.h. Program state structure
(CurrentState) is divided in two parts - StateReader and StateModel.
StateReader saves data packets received from live timing server (without
decryption, it only unpacks them) to cache/replay file;
StateModel decrypts data retrieved from cache and is used for displaying.
Cache file (see src/packetcache.c) is used for replay functionality and
for delay implementation - StateReader writes packets to cache's tail, while
StateModel obtains them from its body (see StateModel::iter).
Such splitting (StateReader/StateModel) can be used in case of
client-retranslation server mode, where several clients connect to one
retranslation server and use various delays (each client has associated
StateModel structure) - such feature may be implemented in future versions.

StateReader uses functions which names contain "pre_handle_"
(continue_pre_handle_stream, pre_handle_packet etc.) to scan packets and make
specific immediate actions (e.g., pre_handle_system_packet may initiate
key frame request on SYS_KEY_FRAME packet) that can modify cache. These
functions are not called in replay mode.
StateModel uses functions which names start with "handle_" to decrypt packet
and change itself; these functions may be delayed (after the reading)
and they cannot modify cache.

Reading process uses two distinct caches which numbers are
StateReader::input_cnum and StateReader::encrypted_cnum. Second cache is common
(StateModel receives packets from it). First one is used as temporary buffer
for stream packets while key frame request is in progress - requested key frame
content must replace SYS_KEY_FRAME packet in encrypted_cnum cache
(packets from key frame are pre-handled and written to encrypted_cnum
immediately; packets from live stream are written to input_cnum, then (see
continue_pre_handle_stream) they are pre-handled and written to encrypted_cnum
if key frame request is not in progress, or wait otherwise).

Delay implementation uses variables StateModel::replay_gap,
StateModel::time_gap, StateModel::model_time.
First one is difference between race time and replay time (replay_gap is 0
in live mode).
Second one is delay itself - wanted gap between packet "pure" visualization
time (as if there were no delay; it is equal to real packet receiving time in
live mode) and real-world time.
StateModel::model_time is virtual time (program visualizes race state at
this time moment); this one tends to the value
<real_world_time> - (time_gap + replay_gap)
but it may differ (see update_model_time).
Delay implementation cannot rewind visualization (model_time cannot decrease)
in the current version.

Asynchronous-related function names come within the following naming
convention: initiator function name starts with "start_" prefix,
callback name starts with "do_" prefix and has same main name part as
related initiator (except in some situations where one initiator initiates
several callbacks).

live-f1 uses the following method to block simultaneous requests: every
function that needs data from other source than live stream server (they are
declared at src/http.h) checks that associated obtaining flag (see
StateReader::obtaining) was not set; if so, then this function continues
execution and initiates asynchronous request, otherwise it stops. This flag
will be cleared at callback. But requests of different types can be in progress
simultaneously, except one special case: if start_get_decryption_key is called
when authentication cookie obtaining is in progress, then decryption key
request becomes pending (see StateReader::pending) and it will be unfreezed
at do_get_auth_cookie callback (start_pending_requests call).

Regular expressions (regex_t) stores via static pointers and initialises one
time (on first use). This memory is never released, but this is not a problem -
there is only limited number of regular expressions in the program. This
solution is chosen to avoid recompilation (regcomp) of the same regex_t before
each use.

Cache/replay file format
------------------------

Cache file contains binary array of unpacked data packets with receiving
timestamp (see Packet at src/packetdef.h). Packet stream can contain
user-defined packets (values with "USER_" prefix at SystemPacketType enum)
that aren't received from the live timing server. Cache file has version
signature (see version_signature at src/packetcache.c); it holds space
equal to one packet size.

Cache file should be replaced by sqlite database in future versions.

Screen drawing
--------------

These functions are defined at src/display.c. Each external function declared
at src/display.h which name starts with "update_" (except update_screen) has
internal counterpart (which name starts with "_update_"). Internal function
makes real work without refreshing virtual screen; external function calls
internal one and refreshes virtual screen. Real screen updating (see
description of wnoutrefresh/pnoutrefresh and doupdate functions in ncurses)
takes place in update_screen function that is called from clear_board and
do_periodic (src/main.c) only. This solution is chosen to minimize the number
of real screen updates.

Asynchronous code flow (basic functions)
----------------------------------------

main (src/main.c):
	calls initiate_reading_process,
	      start_periodic
start_periodic (src/main.c):
	initiates do_periodic callback
do_periodic (src/main.c):
	periodically triggered timeout callback
initiate_reading_process (src/main.c):
	calls start_get_auth_cookie,
	      start_getaddrinfo

start_getaddrinfo (src/stream.c):
	initiates do_getaddrinfo callback
do_getaddrinfo (src/stream.c):
	calls start_connect_stream
start_connect_stream (src/stream.c):
	initiates do_connect_stream callback
do_connect_stream (src/stream.c):
	calls start_connect_stream (on failed connection),
	initiates do_read_stream, do_write_stream, do_event_stream callbacks

start_get_auth_cookie (src/http.c):
	initiates do_get_auth_cookie callback
do_get_auth_cookie (src/http.c):
	calls start_get_auth_cookie (on error),
	      start_pending_requests
